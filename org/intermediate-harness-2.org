#+TITLE: Intermediate Harness: Part Two

* Goal
A slightly more involved scenario, that incorporates a CDS stream. The learning
goals is to understand how to reset the state between scenarios and how to pass
along the discovery response channels between steps.
** Why reset the state?
Our scenarios should be able to be run in any order and be self-contained. There
is nuance in the version numbers being sent back and forth in the xDS protocol,
and we want to make sure our tests can handle them as consistently and simply as
possible.

Ideally, we are not having to restart the management server for each scenario.
Better is to start and connect to it and then contionually reset the state.
* Our Test
This is still a part of the acknack feature set, and so am appending this
scenario to the file.

I am uncertain the best wording for our given test. Basically, we want to have
an established stream setup for the initial state. This means a discovery
request/response/request trade to show that the current version is ACKed by the
client. Then, we want the resources requested to change in some way, and to have
a new discovery response sent, without the client needing to do anything.

This test comes from the envoy docs: [[https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#when-to-send-an-update][When to Send an Update.]] One thing I am
curious on is this section of the doc:
#+begin_quote
The management server should only send updates to the Envoy client when the
resources in the DiscoveryResponse have changed
#+end_quote

If I send a wildcard discovery request, do new resources beign added count as a
change to the resources in the discovery response?

For example, if the initial state only has a single cluster named ~foo~, and so
the response to my first wildcard CDS request is to list that resource. Then,
~bar~ gets added as a cluster. Technically, this wasn't a resource in the first
discovery response, and so wouldn't trigger an update? However, the spirit of
the initial request was for any clusters, which you might think includes ones
made after that request.

I marked this as a question in the org, but for now will only update a resource
in the test and not add a new one.

Here, then, is the initial test:

#+NAME: new resourcescenario
#+begin_src feature
Scenario:
  Given a Target setup with snapshot matching yaml:
  ```
  ---
  node: test-id
  version: "1"
  resources:
  endpoints:
  clusters:
  - name: foo
  connect_timeout:
  seconds: 5
  ```
  And an established CDS stream, with the last discovery request matching yaml:
  ```
  version_info: 1
  node: { id: test-id }
  resource_names:
  type_url: type.googleapis.com/envoy.config.cluster.v3.Cluster
  response_nonce:
  ```
  When Target State is updated to match yaml:
  ```
  ---
  node: test-id
  version: "2"
  resources:
  endpoints:
  clusters:
  - name: foo
  connect_timeout:
  seconds: 10
  ```

  Then I get a discovery response matching yaml:
  ```
  version: 2
  typeUrl:"type.googleapis.com/envoy.config.cluster.v3.Cluster"
  resources:
  - foo
    connect_timeout:
      seconds: 5
  nonce: 2
  ```
#+end_src

There's some particularities in herre to figure out. The discovery request
should have a response nonce, and i need to see if those are dynamic or
not. The discovery response, as compared to intermediate harness, is now explicit yaml instead of a json hash. I will neeed to figure out how to do that.
* Dev Diary
** DONE determine if nonce's are dynamic
For the next set, I think it would be easiest to set up a dummy go program that
has a CDS stream and outputs the discovery responses. It will stay running
listening for the DR's, and I will update the state through a secondary go
routine.

** DONE send back clean yaml/json for resources instead of hash
This was a bit more difficult thatn i first expected due to yaml library
mismatch and a bit of confusion on parsing the discovery responses.

Right now, it takes a discovery response and casts it to the parser's discovery
response type (as this makes it easier for me to parse the yaml). For the
resources, i would like for it to check the resources value type an then do an
anypb unmarshalling to that type, but was finding that increasingly difficult
and so am casting them all to clusters for right now. This is a stopgap to just
get the test working in the general structure i want, but will need to revisit
the go typecasting to make sure I understand the best way to do these data
conversions.

** TODO Set up a stream function that passes requests and responses to our test functions
this is so we can have multiple steps that investigate the discovery responses
we are getting, but not block the process as we wait for the response.
** TODO implement latest test
** TODO setup a reset state function
This looks to be as simple as just adding the snapshot to the cache, in other words, using the existing adapter function.
In practice, it is not that simple.

In the existing test, I have this function:
#+NAME: target setup with snapshot
#+begin_src go
func (r *Runner) aTargetSetupWithSnapshotMatchingYaml(snapYaml *godog.DocString) error {
	snapshot, err := parser.YamlToSnapshot(snapYaml.Content)
	sndsnapshot, err := parser.YamlToSnapshot(thing)
	if err != nil {
		err = fmt.Errorf("Error parsing snapshot yaml: %v", err)
		return err
	}

	c := pb.NewAdapterClient(r.Adapter.Conn)
	_, err = c.SetState(context.Background(), snapshot)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	fmt.Printf("snapshot: %v", snapshot)
	_, err = c.SetState(context.Background(), sndsnapshot)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	return nil
}

#+end_src

I then wrote a var that is identical to the snapshot in our feature, save the connect timeout, and set it to snapshotB,
and rewrote the above function to set the server to snapshot, then snapshotB, then snapshot again
#+NAME: target setup with snapshot
#+begin_src go
func (r *Runner) aTargetSetupWithSnapshotMatchingYaml(snapYaml *godog.DocString) error {
	snapshot, err := parser.YamlToSnapshot(snapYaml.Content)
	snapshotB, err := parser.YamlToSnapshot(snapB)
	if err != nil {
		err = fmt.Errorf("Error parsing snapshot yaml: %v", err)
		return err
	}

	c := pb.NewAdapterClient(r.Adapter.Conn)
	_, err = c.SetState(context.Background(), snapshot)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	fmt.Printf("snapshot: %v", snapshot)
	_, err = c.SetState(context.Background(), sndsnapshot)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	_, err = c.SetState(context.Background(), snapshotB)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	_, err = c.SetState(context.Background(), snapshot)
	if err != nil {
		err = fmt.Errorf("Cannot Set Target with State: %v\n", err)
		return err
	}
	return nil
}

#+end_src

* Questions
** Best phrasing for the test, specifically the ack portion
** Should a discovery response be sent when new resources are added?
see [[If I send a wildcard discovery request, do new resources beign added count as a
change to the resources in the discovery response?][Our Test section]] .
