#+TITLE: Ads Support
#+DATE: 2021-01-18
#+AUTHOR: Zach Mandeville, Mark Roth

** Introduction
This diary is a work-in-progress, documenting how we add ADS support to the xDS
test harness. It starts by checking assumptions I have about ADS, sets out an
initial design for the work, and then acts as a work diary of my pgoress.

The bottom of the document has open questions for which I'd love feedback. When
a question is answered, it'll be removed from that section and its answer woven
into this diary.

** Background
The xDS transport protocol has [[https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#variants-of-the-xds-transport-protocol][four variants]]. Each of the variants are handled
by [[https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#rpc-services-and-methods-for-each-variant][different RPC services/methods]], and so an xDS server can support any or all
of them at the same time.

For example, for LDS, the various protocol variants are provided via the
following RPC methods:

    Basic SotW: ListenerDiscoveryService.StreamListeners Incremental:
    ListenerDiscoveryService.DeltaListeners Aggregated SotW:
    AggregatedDiscoveryService.StreamAggregatedResources Aggregated Incremental:
    AggregatedDiscoveryService.DeltaAggregatedResources

For each of SotW and incremental, the actual communication on the stream will be
essentially the same for both aggregated and non-aggregated, regardless of which
of the above RPC methods you use to create the stream.

For our tests, then, when a test is not variant specific, we should run the same
test for each qualifying variant, by opening a stream with the correct RPC. For
example, with a basic LDS test, our test runner should be able to run it against
both ~ListenerDiscoveryService.StreamListeners~ and
~AggregatedDisocveryService.StreamAggregatedResources~.

Similarly, when we implement tests for the incremental variant, then the test
should run against ~ListenerDiscoveryService.DeltaListeners~ and
~AggregatedDiscoveryService.DeltaAggregatedResources~

A target server may be configured for any subset of combinations from the four
variants, and we should not lock in any required configuration for our tests.
Instead, through something like command line flags, a person can tell the test
runner which variants their implementation supports.

** Design Goals

Our test runner will have a set of flags for each of the variants. A person can use
these flags to narrow the tests run to their server's subset of support variants.

A person should only start the runner once, and then the runner executes the
test suite against the different set variants, by running the right stream
against each of the supported, appropriate RPC methods (as outlined above).

A test may be general enough to work across all variants, or only be appropriate
for a subset. We indicate this, in the test, using tags. The four tags, then,
would be:
- @sotw
- @incremental
- @aggregate
- @separate

If a person invokes the runner as:
: ./runner --sotw --separate --aggregate

Then the runner would go through the test suite twice. Once, running all tests
tagged with ~@sotw~ and ~@separate~, and then running all tests flagged with
~@sotw~ and ~@aggregate~.

In addition, we set a variable in the runner for whether it is testing against
separate or aggregate. This adjusts the RPC methods that are used throughout the
test steps.


Currently, we have a [[https://github.com/ii/xds-test-harness/blob/ads-support/internal/runner/services.go#L54][service builder]] that is passed an xDS service and then sets
up the right kind of stream and opens the required message passing channels. We
could use this same design to build the aggregated service. We then, ideally, do not
need to change the steps much to have this work.

Mainly, we would need to refactor the [[https://github.com/ii/xds-test-harness/blob/ads-support/internal/runner/steps.go#L99][clientSubscribesToService]] function, to
tell it to open an ADS stream instead of a specific stream of the tested
service. We'd also want to make sure our validation steps were only examining
responses with the right type url.

** Process
*** Implement hook for switching between aggregated and separate
*** Refactor functions as necessary
*** Write ADS only test
*** Celebrate and Dance
** Questions
